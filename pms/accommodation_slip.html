<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Slip</title>
    <link rel="icon" type="image/png" href="./logo.png">
    <style>
        :root {
            /* Cream • Gold • Brown palette */
            --bg: #f7efe1; /* page background (cream) */
            --panel: #fffaf1; /* cards/panels (warm off-white) */
            --text: #2b1e15; /* deep brown */
            --muted: #6b5e4a; /* tobacco */
            --gold: #d4af37; /* accent */
            --gold2: #f3d984; /* light accent */
            --edge: #dcc7a4; /* soft border */
            --edge2: #cdb492; /* stronger border */
            --shade: rgba(92,64,28,.10);
            --ok: #2f7d32; /* success */
            --warn: #a86a00; /* warning */
            --pad: 5px;
        }

        /* Base */
        * {
            box-sizing: border-box
        }

        body {
            font: 14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
            background: var(--bg) url("./pattern_gold_2x.png") repeat;
            background-size: 150px auto;
            margin: 15px;
            color: var(--text);
        }

        .wrap {
            max-width: 1700px;
            margin: 10px auto;
            background: var(--panel);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--edge);
            box-shadow: 0 6px 20px var(--shade);
        }

        /* Controls */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-end;
            margin: 6px 0 10px;
        }

        button, select {
            padding: 6px 8px;
            border: 1px solid var(--gold);
            border-radius: 8px;
            background: #fffdf5;
            cursor: pointer;
            font: inherit;
            font-size: 14px;
            color: #7a5b13;
            transition: background .15s ease, transform .08s ease, filter .15s ease;
        }

            button:hover {
                background: #fff6dd
            }

            button:active {
                transform: translateY(1px)
            }

            button:focus-visible, select:focus-visible,
            input:focus-visible, textarea:focus-visible {
                outline: 2px solid color-mix(in oklab, var(--gold) 70%, #ffffff);
                outline-offset: 1px;
            }

        /* Tables */
        .grid {
            width: 100%;
            border-collapse: collapse;
            background: #fff
        }

            .grid th, .grid td {
                border: 1px solid var(--edge);
                padding: var(--pad) 8px;
                vertical-align: middle;
                font-size: 13px;
                color: var(--text);
            }

            .grid th {
                background: #f6ecd6; /* light cream header */
                text-align: center;
                font-weight: 700;
            }

            .grid caption {
                caption-side: top;
                font-weight: 800;
                padding: 6px 0 8px;
                color: #7a5b13;
            }

        .kv th {
            width: 5%;
            text-align: center;
        }

        .kv td[colspan="1"] input,
        .kv td[colspan="1"] select {
            width: 100%;
            text-align: center;
        }

        input[type="text"],
        input[type="number"],
        input[type="date"],
        input[type="time"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--edge2);
            border-radius: 8px;
            font: inherit;
            font-size: 14px;
            background: #fff;
            color: var(--text);
            text-align: center;
        }

        select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--edge2);
            border-radius: 8px;
            background: #fff;
            color: var(--text);
        }

        .inline {
            display: flex;
            gap: 6px;
            align-items: center
        }

            .inline > * {
                flex: 1 1 auto
            }

            .inline button {
                flex: 0 0 auto
            }

        /* Two minis side-by-side */
        .subtables {
            display: flex;
            gap: 8px
        }

        .mini {
            width: 50%;
            border-collapse: collapse;
            background: #fff
        }

            .mini th, .mini td {
                border: 1px solid var(--edge);
                padding: var(--pad)
            }

            .mini th {
                background: #f6ecd6;
                text-align: left
            }

            .mini tfoot td {
                background: #fff8e6
            }

        .row-btn {
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid var(--gold);
            background: #fffdf5;
            cursor: pointer;
            font: inherit;
            color: #7a5b13;
        }

            .row-btn:hover {
                background: #fff6dd
            }

        .help {
            color: var(--muted);
            font-size: 11px;
            margin-top: 4px
        }

        .muted {
            color: var(--muted)
        }

        .toolbar {
            margin-top: 8px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap
        }

        /* Availability highlights */
        .conflict input[type="text"],
        .conflict input[type="number"] {
            border-color: var(--warn);
            background: #fff3e0;
        }

        .okfill input[type="text"],
        .okfill input[type="number"] {
            border-color: var(--ok);
            background: #eef7ef;
        }
    </style>

</head>
<body>


    <!-- Navbar --> <site-nav></site-nav>
    <script type="module" src="./site-nav.js"></script>






    <div class="wrap">

        <table class="grid kv">
            <tbody>
                <tr>
                    <td colspan="2">
                        <div class="inline">
                            <input placeholder="SH Number" id="sh_no" name="sh_no" type="text" />
                            <button id="btnFetchSh" type="button" title="Fetch latest slip with this SH">Fetch</button>


                        </div>
                    </td>
                    <td colspan="4"><input placeholder="Tour Name" id="tour_name" type="text" placeholder="" /></td>
                    <td colspan="4"><input placeholder="Group Leader Name" id="group_leader" type="text" placeholder="" /></td>

                    </td>

                    <th>G</th>
                    <td><input placeholder="Gents" id="gents" type="number" inputmode="numeric" min="0" step="1" /></td>
                    <th>L</th>
                    <td><input placeholder="Ladies" id="ladies" type="number" inputmode="numeric" min="0" step="1" /></td>
                    <td colspan="2">
                        <select placeholder="Building" id="building">
                            <option value="">Select building…</option>
                            <option>MOHAMMEDI</option>
                            <option>MUFADDAL</option>
                            <option>SNOOD</option>
                            <option>BAHA</option>
                            <option>HUSN</option>
                        </select>


                </tr>
                <tr>

                    <th>CHECK IN</th>
                    <td><input id="checkin_date" type="date" /></td>
                    <td colspan="2"><input id="checkin_time" type="time" /></td>
                    <th>CHECK OUT</th>
                    <td><input id="checkout_date" type="date" /></td>
                    <td colspan="2"><input id="checkout_time" type="time" /></td>

                    <th>T</th>
                    <td><input placeholder="Total" id="total" type="number" inputmode="numeric" min="0" step="1" /></td>
                    <th>I</th>
                    <td><input placeholder="Infants" id="infants" type="number" inputmode="numeric" min="0" step="1" /></td>
                    <th>C</th>
                    <td><input placeholder="Children" id="children" type="number" inputmode="numeric" min="0" step="1" /></td>

                </tr>
                <tr>
                </tr>

            </tbody>
        </table>

        <!-- Bulk room import -->
        <div class="bulk-row">

            <input id="gentsBulk" type="text" placeholder="Gents Rooms: 501-502-503" />
            <input id="ladiesBulk" type="text" placeholder="Ladies Rooms: 401-402-403" />
            <button id="btnBulkLoad" type="button">Load</button>
            <span id="bulkReport" class="muted"></span>
        </div>

        <script>


            /* ========= Bulk Rooms: multi-separator + bold big beds count ========= */

            /* Split by: comma, slash, asterisk, dash, any whitespace (space/newline/tab) */
            function bulkParse(str) {
                if (!str) return [];
                const parts = str
                    .split(/[,\s\/\*\-\.]+/)      // separators: ,  /  *  -  any whitespace
                    .map(s => s.trim())
                    .filter(Boolean);

                // de-dupe case-insensitively, preserve order
                const out = [];
                const seen = new Set();
                for (const r of parts) {
                    const k = r.toLowerCase();
                    if (!seen.has(k)) { seen.add(k); out.push(r); }
                }
                return out;
            }

            /* Replace rows for a group with provided room list */
            function bulkFillGroup(group, rooms) {
                const tbody = document.getElementById(group + "-tbody");
                if (!tbody) return;
                tbody.innerHTML = "";
                if (!rooms.length) { addRow(group); return; }
                rooms.forEach(r => addRow(group, { room_no: r, capacity: "" }));
            }

            /* Sum numeric capacities across both tables (gents + ladies) */
            function sumAssignedBeds() {
                const sumFor = (group) => {
                    let s = 0;
                    document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => {
                        const capEl = tr.querySelector('td:nth-child(2) input');
                        const n = Number(capEl && capEl.value);
                        if (Number.isFinite(n)) s += n;
                    });
                    return s;
                };
                return sumFor('gents') + sumFor('ladies');
            }

            /* Main action: load lists → fetch capacities → show bold big beds count */
            async function bulkLoadRooms() {
                const gRooms = bulkParse(document.getElementById("gentsBulk").value);
                const lRooms = bulkParse(document.getElementById("ladiesBulk").value);

                bulkFillGroup("gents", gRooms);
                bulkFillGroup("ladies", lRooms);

                if (typeof fetchCapacities === "function") {
                    await fetchCapacities();
                }

                const bedsAssigned = sumAssignedBeds();
                const rep = document.getElementById("bulkReport");
                if (rep) {
                    rep.innerHTML = `Beds assigned: <span id="bedsAssignedVal">${bedsAssigned}</span>`;
                    // make it big and bold
                    const val = document.getElementById("bedsAssignedVal");
                    rep.style.fontWeight = "700";
                    rep.style.fontSize = "22px";
                    rep.style.color = "#654321";
                    if (val) { val.style.fontWeight = "800"; val.style.fontSize = "26px"; }
                }

                if (typeof updateTotals === "function") updateTotals();
                const s = document.getElementById("status");
                if (s) s.textContent = `Bulk loaded; beds assigned = ${bedsAssigned}.`;
            }

            /* Wire the button and Enter key on inputs */
            (function wireBulk() {
                const btn = document.getElementById("btnBulkLoad");
                if (btn) btn.addEventListener("click", bulkLoadRooms);
                ["gentsBulk", "ladiesBulk"].forEach(id => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    el.addEventListener("keydown", e => {
                        if (e.key === "Enter") { e.preventDefault(); bulkLoadRooms(); }
                    });
                });
            })();
        </script>




        <div class="subtables" style="margin-top:16px;">
            <table class="mini" id="tblGents">
                <caption>GENTS — Rooms</caption>
                <!-- GENTS header: was Room No | Capacity | [X] -->
                <thead>
                    <tr>
                        <th style="width:50%">Room No</th>
                        <th style="width:22%">Capacity</th>
                        <th style="width:18%">Assigned</th>
                        <th style="width:10%"></th>
                    </tr>
                </thead>

                <tbody id="gents-tbody"></tbody>
                <tfoot>
                    <tr><td colspan="3"><button class="row-btn" onclick="addRow('gents')">Add Row</button></td></tr>
                </tfoot>
            </table>

            <table class="mini" id="tblLadies">
                <caption>LADIES — Rooms</caption>
                <!-- LADIES header: same change -->
                <thead>
                    <tr>
                        <th style="width:50%">Room No</th>
                        <th style="width:22%">Capacity</th>
                        <th style="width:18%">Assigned</th>
                        <th style="width:10%"></th>
                    </tr>
                </thead>

                <tbody id="ladies-tbody"></tbody>
                <tfoot>
                    <tr><td colspan="3"><button class="row-btn" onclick="addRow('ladies')">Add Row</button></td></tr>
                </tfoot>
            </table>
        </div>

        <div class="toolbar no-print">
            <button id="btnFetchCap">Fetch &amp; Assign</button>
            <button id="btnCheckAvail">Check room availability</button>
        </div>

        <div class="help no-print">
            Use <b>Fetch capacity data</b> after you enter room numbers. Unknown rooms show capacity placeholder <b>“unassigned.”</b><br />
            Use <b>Check room availability</b> to catch conflicts before saving.
        </div>

        <div class="controls no-print">
            <button id="btnNew">New Slip</button>
            <button id="btnSave">Save</button>
            <button id="btnEdit">Edit</button>
            <span class="muted" id="status"></span>
        </div>
    </div>

    <script>

        /* -------------------------- IndexedDB setup -------------------------- */
        const DB_NAME = 'pms_accommodation_db';
        const STORE = 'slips';
        const DB_VERSION = 2;

        function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, DB_VERSION);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    let store;
                    if (!db.objectStoreNames.contains(STORE)) {
                        store = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
                    } else {
                        store = e.target.transaction.objectStore(STORE);
                    }
                    if (!store.indexNames.contains('createdAt')) store.createIndex('createdAt', 'createdAt', { unique: false });
                    if (!store.indexNames.contains('tour_name')) store.createIndex('tour_name', 'tour_name', { unique: false });
                    if (!store.indexNames.contains('sh_no')) store.createIndex('sh_no', 'sh_no', { unique: false });
                    if (!store.indexNames.contains('building')) store.createIndex('building', 'building', { unique: false });
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
        async function addRecord(data) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readwrite');
                const store = tx.objectStore(STORE);
                const req = store.add(data);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
                tx.oncomplete = () => db.close();
            });
        }
        async function updateRecord(id, patch) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readwrite');
                const store = tx.objectStore(STORE);
                const getReq = store.get(Number(id));
                getReq.onsuccess = () => {
                    const old = getReq.result;
                    if (!old) { reject(new Error('Record not found')); return; }
                    const updated = { ...old, ...patch, id: old.id, createdAt: old.createdAt, updatedAt: new Date().toISOString() };
                    const putReq = store.put(updated);
                    putReq.onsuccess = () => resolve(updated.id);
                    putReq.onerror = () => reject(putReq.error);
                };
                getReq.onerror = () => reject(getReq.error);
                tx.oncomplete = () => db.close();
            });
        }
        async function getAllRecords() {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readonly');
                const store = tx.objectStore(STORE);
                const req = store.getAll();
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => reject(req.error);
                tx.oncomplete = () => db.close();
            });
        }
        async function getRecord(id) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readonly');
                const store = tx.objectStore(STORE);
                const req = store.get(Number(id));
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => reject(req.error);
                tx.oncomplete = () => db.close();
            });
        }
        function reqToPromise(req) {
            return new Promise((resolve, reject) => {
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
        function toTs(v) {
            if (!v) return 0;
            if (v instanceof Date) return +v;
            const n = Date.parse(v);
            if (!Number.isNaN(n)) return n;
            const k = Number(v);
            return Number.isFinite(k) ? k : 0;
        }
        function toNum(v) {
            const n = Number(v);
            return Number.isFinite(n) ? n : 0;
        }
        function shCandidates(sh) {
            const raw = String(sh ?? "").trim();
            const out = [raw];
            const num = Number(raw);
            if (!Number.isNaN(num)) out.push(num);
            return [...new Set(out)];
        }

        /* FIXED VERSION */
        async function getLatestBySh(sh) {
            const db = await openDB();
            const tx = db.transaction(STORE, 'readonly');
            const store = tx.objectStore(STORE);
            const cands = shCandidates(sh);
            let rows = [];

            try {
                if (store.indexNames.contains('sh_no')) {
                    const idx = store.index('sh_no');
                    for (const key of cands) {
                        const chunk = await reqToPromise(idx.getAll(key));
                        if (Array.isArray(chunk) && chunk.length) rows.push(...chunk);
                    }
                } else {
                    const all = await reqToPromise(store.getAll());
                    rows = all.filter(r =>
                        cands.includes(r.sh_no) || cands.includes(Number(r.sh_no))
                    );
                }

                rows.sort((a, b) => {
                    const tb = toTs(b.createdAt), ta = toTs(a.createdAt);
                    if (tb !== ta) return tb - ta;
                    return toNum(b.id) - toNum(a.id);
                });

                return rows[0] || null;
            } finally {
                // Let the transaction finish before closing
                setTimeout(() => { try { db.close(); } catch (_) { } }, 0);
            }
        }

        /* ------------------------------ Helpers ----------------------------- */
        function $(id) { return document.getElementById(id); }
        let CURRENT_ID = null;
        let DB_CACHE = []; // for capacity + availability lookup

        function pad(n) { return String(n).padStart(2, '0'); }
        function parseDT(d, t) { if (!d) return null; const tt = t && t.length ? t : '00:00'; const v = new Date(`${d}T${tt}`); return isNaN(v) ? null : v; }
        function fmt(dt) { if (!dt) return ''; return new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(dt); }
        function cleanRoom(x) { return String(x ?? '').trim(); }
        function uniq(arr) { return Array.from(new Set(arr)); }

        async function refreshDBCache() {
            DB_CACHE = await getAllRecords();
        }

        function addRow(group, data = { room_no: '', capacity: '', assigned: '' }) {
            const tbody = $(group + '-tbody');
            const tr = document.createElement('tr');

            // Room
            const tdRoom = document.createElement('td');
            const inpRoom = document.createElement('input');
            inpRoom.type = 'text';
            inpRoom.placeholder = '';
            inpRoom.value = data.room_no || '';
            tdRoom.appendChild(inpRoom);

            // Capacity (reference/nominal)
            const tdCap = document.createElement('td');
            const inpCap = document.createElement('input');
            inpCap.type = 'number';
            inpCap.min = '0';
            inpCap.step = '1';
            inpCap.inputMode = 'numeric';
            inpCap.value = (data.capacity ?? '') === '' ? '' : String(data.capacity);
            tdCap.appendChild(inpCap);

            // Assigned (mirrors capacity until the user edits it)
            const tdAsg = document.createElement('td');
            const inpAsg = document.createElement('input');
            inpAsg.type = 'number';
            inpAsg.min = '0';
            inpAsg.step = '1';
            inpAsg.inputMode = 'numeric';
            inpAsg.placeholder = 'assigned';
            tdAsg.appendChild(inpAsg);

            // Wire mirroring
            bindAssignedToCapacity(inpCap, inpAsg, data.assigned);

            // ========= helper =========
            function bindAssignedToCapacity(cap, asg, initialAssigned) {
                // if you already have an explicit assigned value, respect it and stop auto-sync
                const hasAssigned = initialAssigned != null && initialAssigned !== '';
                let dirty = hasAssigned;

                asg.value = hasAssigned ? String(initialAssigned) : String(cap.value ?? '');

                const sync = () => { if (!dirty) asg.value = cap.value; };

                // user-driven changes on capacity
                cap.addEventListener('input', sync);
                cap.addEventListener('change', sync);

                // first edit on assigned makes it user-owned
                asg.addEventListener('input', () => { dirty = true; });

                // catch programmatic cap.value = '...' (no input event fired)
                patchValueSetter(cap, sync);
            }

            // fire `input` whenever .value is set programmatically on this element
            function patchValueSetter(input, onSet) {
                if (input.__patchedValueSetter) return; // don’t double-patch
                input.__patchedValueSetter = true;

                const proto = Object.getPrototypeOf(input);
                const desc = Object.getOwnPropertyDescriptor(proto, 'value')
                    || Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');

                const _get = desc.get;
                const _set = desc.set;

                Object.defineProperty(input, 'value', {
                    configurable: true,
                    enumerable: desc.enumerable,
                    get() { return _get.call(this); },
                    set(v) {
                        _set.call(this, v);
                        try { onSet && onSet(); } catch (_) { }
                        // also emit a synthetic input so any of your other listeners notice
                        this.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                });
            }



            // Delete
            const tdDel = document.createElement('td');
            const btnDel = document.createElement('button');
            btnDel.className = 'row-btn';
            btnDel.type = 'button';
            btnDel.textContent = 'X';
            btnDel.title = 'Delete row';
            btnDel.onclick = () => tr.remove();
            tdDel.appendChild(btnDel);

            tr.append(tdRoom, tdCap, tdAsg, tdDel);
            tbody.appendChild(tr);
        }


        function collectRows(group) {
            const rows = [];
            document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => {
                const [roomNoEl, capEl, asgEl] = tr.querySelectorAll('input');
                const room_no = (roomNoEl?.value || '').trim();

                const capRaw = (capEl?.value || '').trim();
                const capacity = /^\d+$/.test(capRaw) ? Number(capRaw) : '';

                const asgRaw = (asgEl?.value || '').trim();
                const assigned = /^\d+$/.test(asgRaw) ? Number(asgRaw) : '';

                // Only push if anything is filled
                if (room_no !== '' || capRaw !== '' || asgRaw !== '') {
                    rows.push({ room_no, capacity, assigned });
                }
            });
            return rows;
        }


        function setRows(group, arr) {
            const tbody = $(group + '-tbody');
            tbody.innerHTML = '';
            if (!arr || !arr.length) { addRow(group); return; }
            arr.forEach(r => addRow(group, r)); // r may include r.assigned
        }


        function getFormData() {
            return {
                tour_name: $('tour_name').value.trim(),
                group_leader: $('group_leader').value.trim(),
                checkin_date: $('checkin_date').value || '',
                checkin_time: $('checkin_time').value || '',
                checkout_date: $('checkout_date').value || '',
                checkout_time: $('checkout_time').value || '',
                building: $('building').value || '',
                sh_no: $('sh_no').value === '' ? '' : Number($('sh_no').value),
                total: $('total').value === '' ? '' : Number($('total').value),
                gents: $('gents').value === '' ? '' : Number($('gents').value),
                ladies: $('ladies').value === '' ? '' : Number($('ladies').value),
                infants: $('infants').value === '' ? '' : Number($('infants').value),
                children: $('children').value === '' ? '' : Number($('children').value),
                rooms: {
                    gents: collectRows('gents'),
                    ladies: collectRows('ladies')
                },
                createdAt: new Date().toISOString()
            };
        }

        function setFormData(data) {
            $('tour_name').value = data.tour_name || '';
            $('group_leader').value = data.group_leader || '';
            $('checkin_date').value = data.checkin_date || '';
            $('checkin_time').value = data.checkin_time || '';
            $('checkout_date').value = data.checkout_date || '';
            $('checkout_time').value = data.checkout_time || '';
            $('building').value = data.building || '';
            $('sh_no').value = data.sh_no ?? '';
            $('total').value = data.total ?? '';
            $('gents').value = data.gents ?? '';
            $('ladies').value = data.ladies ?? '';
            $('infants').value = data.infants ?? '';
            $('children').value = data.children ?? '';
            setRows('gents', data.rooms?.gents || []);
            setRows('ladies', data.rooms?.ladies || []);
        }

        function clearForm() {
            CURRENT_ID = null;
            setFormData({
                tour_name: '', group_leader: '', checkin_date: '', checkin_time: '',
                checkout_date: '', checkout_time: '', building: '', sh_no: '',
                total: '', gents: '', ladies: '', infants: '', children: '',
                rooms: { gents: [], ladies: [] }
            });
        }

        /* ------------------------ Saved list UI ------------------------ */


        /* ---------------- Capacity lookup (most recent per building|room) --------------- */
        function buildCapacityMap(buildingFilter) {
            const cap = new Map(); // key: building|room -> capacity
            const items = [...DB_CACHE].sort((a, b) => (a.createdAt > b.createdAt ? -1 : 1));
            for (const r of items) {
                const b = (r.building || '').trim();
                if (buildingFilter && b !== buildingFilter) continue;
                (r.rooms?.gents || []).forEach(x => {
                    const key = `${b}|${cleanRoom(x.room_no)}`;
                    const c = (x.capacity === '' || x.capacity == null) ? null : Number(x.capacity);
                    if (!cap.has(key) && c != null) cap.set(key, c);
                });
                (r.rooms?.ladies || []).forEach(x => {
                    const key = `${b}|${cleanRoom(x.room_no)}`;
                    const c = (x.capacity === '' || x.capacity == null) ? null : Number(x.capacity);
                    if (!cap.has(key) && c != null) cap.set(key, c);
                });
            }
            return cap;
        }

        function setUnassigned(input) {
            input.value = '';
            input.placeholder = 'unassigned';
        }

        /* Fill capacities for both tables based on entered rooms */
        async function fetchCapacities() {
            await refreshDBCache();
            const b = ($('building').value || '').trim();
            if (!b) { alert('Select a building first.'); return; }
            const capMap = buildCapacityMap(b);

            let filled = 0, unknown = 0;

            ['gents', 'ladies'].forEach(group => {
                document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => {
                    tr.classList.remove('okfill');
                    const [roomEl, capEl] = tr.querySelectorAll('input');
                    const room = cleanRoom(roomEl.value);
                    if (!room) return;
                    const key = `${b}|${room}`;
                    if (capMap.has(key)) {
                        capEl.value = capMap.get(key);
                        capEl.placeholder = '';
                        tr.classList.add('okfill');
                        filled++;
                    } else {
                        setUnassigned(capEl);
                        unknown++;
                    }
                });
            });

            $('status').textContent = `Capacity fetch: filled ${filled} item(s); ${unknown} unassigned.`;
        }

        /* ---------------- Availability check ---------------- */
        function overlaps(aStart, aEnd, bStart, bEnd) {
            return aStart < bEnd && aEnd > bStart; // [start, end)
        }

        function highlightConflicts(confRooms) {
            // wipe
            ['gents', 'ladies'].forEach(group => {
                document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => tr.classList.remove('conflict'));
            });
            if (!confRooms.size) return;
            ['gents', 'ladies'].forEach(group => {
                document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => {
                    const [roomEl] = tr.querySelectorAll('input');
                    const room = cleanRoom(roomEl.value);
                    if (confRooms.has(room)) tr.classList.add('conflict');
                });
            });
        }

        async function checkAvailability() {
            await refreshDBCache();

            const bld = ($('building').value || '').trim();
            const ci = parseDT($('checkin_date').value, $('checkin_time').value);
            const co = parseDT($('checkout_date').value, $('checkout_time').value);

            if (!bld || !ci || !co || co <= ci) {
                alert('Enter a valid building and check-in/check-out window first.');
                return false;
            }

            // Collect current rows with per-room wanted assignment and local capacity
            const rowsAll = [...collectRows('gents'), ...collectRows('ladies')];
            const roomInfo = new Map(); // room -> { want, capLocal }
            for (const r of rowsAll) {
                const room = cleanRoom(r.room_no);
                if (!room) continue;
                const want = Number.isFinite(+r.assigned) ? +r.assigned : 0;
                const capLocal = Number.isFinite(+r.capacity) ? +r.capacity : 0;
                const prev = roomInfo.get(room) || { want: 0, capLocal: 0 };
                roomInfo.set(room, {
                    want: prev.want + want,
                    capLocal: prev.capLocal || capLocal
                });
            }
            const uniqRooms = Array.from(roomInfo.keys());
            // if you want to force at least one room, uncomment:
            // if (!uniqRooms.length){ alert('Enter at least one room number.'); return false; }

            // Per-room stats from overlapping OTHER slips
            const stats = new Map(); // room -> { existing: number, freeAt: Date|null }
            for (const room of uniqRooms) stats.set(room, { existing: 0, freeAt: null });

            for (const r of DB_CACHE) {
                if (CURRENT_ID && r.id === CURRENT_ID) continue; // ignore self
                const rb = (r.building || '').trim();
                if (rb !== bld) continue;

                const rci = parseDT(r.checkin_date, r.checkin_time);
                const rco = parseDT(r.checkout_date, r.checkout_time);
                if (!rci || !rco) continue;
                if (!overlaps(ci, co, rci, rco)) continue; // no overlap with our window

                const used = [
                    ...(r.rooms?.gents || []),
                    ...(r.rooms?.ladies || [])
                ];

                for (const x of used) {
                    const room = cleanRoom(x.room_no);
                    if (!room || !roomInfo.has(room)) continue; // only care about rooms we’re assigning now
                    const s = stats.get(room);
                    const a = Number.isFinite(+x.assigned) ? +x.assigned : 0;
                    s.existing += a;
                    // latest checkout among overlapping stays decides "free at"
                    if (!s.freeAt || s.freeAt < rco) s.freeAt = rco;
                }
            }

            // Helper: resolve capacity from current row first, otherwise read last-known from history
            function resolveCapacity(room) {
                const local = roomInfo.get(room)?.capLocal || 0;
                if (local > 0) return local;
                // fallback scan: most recent non-zero capacity in DB history for this building+room
                for (let i = DB_CACHE.length - 1; i >= 0; i--) {
                    const rec = DB_CACHE[i];
                    const rb = (rec.building || '').trim();
                    if (rb !== bld) continue;
                    const arr = [...(rec.rooms?.gents || []), ...(rec.rooms?.ladies || [])];
                    const hit = arr.find(z => cleanRoom(z.room_no) === room);
                    const histCap = Number.isFinite(+hit?.capacity) ? +hit.capacity : 0;
                    if (histCap > 0) return histCap;
                }
                return 0; // unknown
            }

            // Decide per room: allowed when (existing + want) < capacity
            const blocked = new Set();
            const lines = [];

            for (const room of uniqRooms) {
                const { want } = roomInfo.get(room);
                const existing = stats.get(room)?.existing || 0;
                const freeAt = stats.get(room)?.freeAt || null;
                const cap = resolveCapacity(room);

                if (!cap) {
                    blocked.add(room);
                    lines.push(`${room}: capacity unknown. Enter capacity for this slip.`);
                    continue;
                }

                const after = existing + (Number.isFinite(+want) ? +want : 0);
                const remaining = Math.max(0, cap - existing);

                if (after < cap + 1) {
                    // Allowed even if overlaps exist; tell how much room is left
                    const remainingNow = Math.max(0, cap - after);
                    lines.push(`${room}: OK. Before Assigned: ${existing}/${cap}. After Assignment: ${after}/${cap}. Remaining now ${remainingNow}.`);
                } else {
                    // Block when total would meet or exceed capacity
                    blocked.add(room);
                    const freeStr = freeAt ? fmt(freeAt) : '(checkout unknown)';
                    lines.push(`${room}: BLOCKED. Existing ${existing}/${cap}, assigning ${want || 0} would be ${after}/${cap}. Expected chechout after ${freeStr}.`);
                }
            }

            highlightConflicts(blocked);

            if (blocked.size) {
                alert(lines.join('\n'));
                $('status').textContent = `${blocked.size} room(s) at or over capacity.`;
                return false;
            } else {
                alert(lines.join('\n') + '\nAll entered rooms are available within capacity.');
                $('status').textContent = 'Availability OK.';
                return true;
            }
        }


        /* ---------------------------- Events --------------------------- */

        $('btnSave').addEventListener('click', async () => {
            try {
                const data = getFormData();
                const ok = await checkAvailability(); // optional guard; comment out if you want silent save
                if (ok === false) return;
                const id = await addRecord(data);
                CURRENT_ID = id;
                $('status').textContent = `Saved as #${id}`;
            } catch (err) {
                $('status').textContent = 'Save failed. Check console.';
                console.error('Save error:', err);
                alert('Failed to save. Your browser may block IndexedDB in this context.');
            }
        });

        $('btnEdit').addEventListener('click', async () => {
            try {
                if (!CURRENT_ID) { alert('Load a slip (Saved list or SH Fetch) before editing.'); return; }
                const data = getFormData();
                const ok = await checkAvailability(); // validate before edit too
                if (ok === false) return;
                delete data.createdAt; // keep original
                const id = await updateRecord(CURRENT_ID, data);
                $('status').textContent = `Updated #${id}`;
                postDbToTelegram('edit').catch(console.warn);
            } catch (err) {
                $('status').textContent = 'Edit failed. See console.';
                console.error('Edit error:', err);
                alert('Edit failed.');
            }
        });



        $('btnNew').addEventListener('click', () => {
            clearForm();
            $('status').textContent = 'New blank slip';
        });

        $('btnFetchSh').addEventListener('click', async () => {
            const raw = $('sh_no').value;
            if (raw === '' || isNaN(Number(raw))) { alert('Enter a valid SH No.'); return; }
            const rec = await getLatestBySh(Number(raw));
            if (!rec) { $('status').textContent = 'No slip found for that SH.'; return; }
            CURRENT_ID = rec.id;
            setFormData(rec);
            $('status').textContent = `Loaded latest slip for SH ${rec.sh_no} (#${rec.id})`;
        });

        $('sh_no').addEventListener('blur', async () => {
            const hasAny = ($('tour_name').value || $('group_leader').value || $('building').value);
            if (hasAny) return;
            const raw = $('sh_no').value;
            if (raw !== '' && !isNaN(Number(raw))) {
                const rec = await getLatestBySh(Number(raw));
                if (rec) {
                    CURRENT_ID = rec.id;
                    setFormData(rec);
                    $('status').textContent = `Auto-loaded latest slip for SH ${rec.sh_no} (#${rec.id})`;
                }
            }
        });

        $('btnFetchCap').addEventListener('click', fetchCapacities);
        $('btnCheckAvail').addEventListener('click', checkAvailability);

        /* ------------------------------ Boot ------------------------------- */
        (async function boot() {
            clearForm();
            addRow('gents'); addRow('ladies');
            await refreshDBCache();
        })();
    </script>
    <script>
        /* === GLOBAL CONFIG (yes, hardcoded like you wanted) === */
        // const DB_NAME = "pms_accommodation_db";
        const TG_BOT_TOKEN = "8159532809:AAG_183ak6FWeaQ1mhBgqh7ATGq9k2e1fUM";
        const TG_CHAT_ID = "@pms4427";  // if Telegram says "chat not found", swap for numeric -100xxxxxxxxxxxx

        /* === 1) Dump the entire IndexedDB (global) === */
        window.dumpIndexedDB = async function dumpIndexedDB(dbName = DB_NAME) {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(dbName);
                let createdEmpty = false;

                req.onupgradeneeded = () => { createdEmpty = true; };

                req.onerror = () => reject(req.error);

                req.onsuccess = () => {
                    const db = req.result;
                    const storeNames = Array.from(db.objectStoreNames || []);
                    const out = {
                        meta: { dbName: db.name, version: db.version, storeCount: storeNames.length },
                        stores: {}
                    };

                    if (createdEmpty || storeNames.length === 0) {
                        db.close(); resolve(out); return;
                    }

                    let remaining = storeNames.length;

                    storeNames.forEach(storeName => {
                        const tx = db.transaction(storeName, "readonly");
                        const store = tx.objectStore(storeName);

                        const meta = {
                            name: storeName,
                            keyPath: store.keyPath || null,
                            autoIncrement: !!store.autoIncrement,
                            indexes: Array.from(store.indexNames || []).map(ixName => {
                                const ix = store.index(ixName);
                                return { name: ix.name, keyPath: ix.keyPath, unique: ix.unique, multiEntry: ix.multiEntry };
                            })
                        };

                        const rows = [];
                        const curReq = store.openCursor();

                        curReq.onsuccess = e => {
                            const cursor = e.target.result;
                            if (cursor) {
                                if (store.keyPath) rows.push(cursor.value);
                                else rows.push({ key: cursor.primaryKey, value: cursor.value });
                                cursor.continue();
                            } else {
                                out.stores[storeName] = { meta, rowsCount: rows.length, rows };
                                if (--remaining === 0) { db.close(); resolve(out); }
                            }
                        };

                        curReq.onerror = () => {
                            out.stores[storeName] = { meta, error: String(curReq.error || "cursor error"), rows: [] };
                            if (--remaining === 0) { db.close(); resolve(out); }
                        };
                    });
                };
            });
        };

        /* === 2) Post a JSON file to Telegram via hidden form (global) === */
        window.telegramSendDocument = function telegramSendDocument(filename, jsonObject, caption = "") {
            let iframe = document.getElementById("tg_iframe_sink");
            if (!iframe) {
                iframe = document.createElement("iframe");
                iframe.name = "tg_iframe_sink";
                iframe.id = "tg_iframe_sink";
                iframe.style.display = "none";
                document.body.appendChild(iframe);
            }

            const form = document.createElement("form");
            form.method = "POST";
            form.enctype = "multipart/form-data";
            form.action = `https://api.telegram.org/bot${TG_BOT_TOKEN}/sendDocument`;
            form.target = "tg_iframe_sink";

            const chat = document.createElement("input");
            chat.type = "hidden"; chat.name = "chat_id"; chat.value = TG_CHAT_ID; form.appendChild(chat);

            const cap = document.createElement("input");
            cap.type = "hidden"; cap.name = "caption";
            cap.value = caption || `PMS dump • ${new Date().toISOString()}`;
            form.appendChild(cap);

            const fileInput = document.createElement("input");
            fileInput.type = "file"; fileInput.name = "document"; fileInput.style.display = "none";
            form.appendChild(fileInput);

            const blob = new Blob([JSON.stringify(jsonObject, null, 2)], { type: "application/json" });
            const file = new File([blob], filename || `pms_dump_${Date.now()}.json`, { type: "application/json" });

            const dt = new DataTransfer();
            dt.items.add(file);
            fileInput.files = dt.files;

            document.body.appendChild(form);
            form.submit();
            setTimeout(() => form.remove(), 1500);
        };

        /* === 3) One-call: dump DB + post to Telegram (global) === */
        window.postDbToTelegram = async function postDbToTelegram(reason = "edit") {
            const snapshot = {
                reason,
                ts: new Date().toISOString(),
                page: location.href,
                db: await window.dumpIndexedDB(DB_NAME)
            };
            window.telegramSendDocument(`pms_accommodation_${Date.now()}.json`, snapshot);
            const s = document.getElementById("status");
            if (s) s.textContent = "JSON posted to Telegram group.";
        };
    </script>




</body>
</html>