<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Slip</title>
    <link rel="icon" type="image/png" href="./logo.png">
    <style>
        :root {
            --border: #d6d6d6;
            --muted: #7a7a7a;
            --pad: 5px;
            --warn: #b91c1c;
            --ok: #0f766e;
        }


        /* Base */
        body {
            font: 14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
            background: #ffffff url("./pattern_gold_2x.png") repeat;
            background-size: 150px auto; /* larger tile = calmer page */
            margin: 15px;
            color: #111;
        }

        .wrap {
            max-width: 1500px;
            margin: 10px auto;
            background: #fff;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 3px 12px rgba(0,0,0,.06);
        }


        /* Controls */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-end;
            margin: 6px 0 10px;
        }

        button, select {
            padding: 6px 8px;
            border: 1px solid #c9c9c9;
            border-radius: 6px;
            background: #fff;
            cursor: pointer;
            font: inherit;
            font-size: 14px;
        }

            button:hover {
                background: #f0f0f0
            }

        /* Tables */
        .grid {
            width: 100%;
            border-collapse: collapse;
        }

            .grid th, .grid td {
                border: 1px solid var(--border);
                padding: var(--pad) 8px;
                vertical-align: middle;
                font-size: 13px;
            }

            .grid th {
                background: #fafafa;
                text-align: left;
                font-weight: 700;
            }

            .grid caption {
                caption-side: top;
                font-weight: 800;
                padding: 6px 0 8px;
            }

        .kv th {
            width: 5%
        }

        .kv td[colspan="1"] input,
        .kv td[colspan="1"] select {
            width: 80%
        }

        input[type="text"],
        input[type="number"],
        input[type="date"],
        input[type="time"] {
            width: 80%;
            padding: 6px;
            border: 1px solid #bbb;
            border-radius: 6px;
            font: inherit;
            font-size: 14px;
            background: #fff;
        }

        select {
            width: 100%;
            padding: 6px;
            border: 1px solid #bbb;
            border-radius: 6px;
            background: #fff;
        }

        .inline {
            display: flex;
            gap: 6px;
            align-items: center;
        }

            .inline > * {
                flex: 1 1 auto
            }

            .inline button {
                flex: 0 0 auto
            }

        /* Two minis side-by-side */
        .subtables {
            display: flex;
            gap: 8px;
        }

        .mini {
            width: 50%;
            border-collapse: collapse;
        }

            .mini th, .mini td {
                border: 1px solid var(--border);
                padding: var(--pad);
            }

            .mini th {
                background: #f6f6f6;
                text-align: left
            }

            .mini tfoot td {
                background: #fafafa
            }

        .row-btn {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #bbb;
            background: #fff;
            cursor: pointer;
            font: inherit;
        }

            .row-btn:hover {
                background: #f0f0f0
            }

        .help {
            color: var(--muted);
            font-size: 11px;
            margin-top: 4px
        }

        .muted {
            color: var(--muted)
        }

        .toolbar {
            margin-top: 8px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        /* Availability highlights */
        .conflict input[type="text"],
        .conflict input[type="number"] {
            border-color: var(--warn);
            background: #fff7f7;
        }

        .okfill input[type="text"],
        .okfill input[type="number"] {
            border-color: var(--ok);
            background: #f3fcfa;
        }
       



    </style>
</head>
<body>


    <!-- Navbar --> <site-nav></site-nav> <script type="module" src="./site-nav.js"></script>






    <div class="wrap">

        <table class="grid kv">
            <tbody>
                <tr>
                    <td colspan="2">
                        <div class="inline">
                            <input placeholder="SH Number" id="sh_no" type="number" inputmode="numeric" min="0" step="1" />
                            <button id="btnFetchSh" title="Fetch latest slip with this SH">Fetch</button>
                        </div>
                    </td>
                    <td colspan="2"><input placeholder="Tour Name" id="tour_name" type="text" placeholder="" /></td>
                    <td colspan="2"><input placeholder="Group Leader Name" id="group_leader" type="text" placeholder="" /></td>
                    <td colspan="2">
                        <select placeholder="Building" id="building">
                            <option value="">Select building…</option>
                            <option>MOHAMMEDI</option>
                            <option>MUFADDAL</option>
                            <option>SNOOD</option>
                            <option>BAHA</option>
                            <option>HUSN</option>
                        </select>
                    </td>
                    <td><input placeholder="Gents" id="gents" type="number" inputmode="numeric" min="0" step="1" /></td>
                    <td><input placeholder="Ladies" id="ladies" type="number" inputmode="numeric" min="0" step="1" /></td>

                </tr>
                <tr>

                    <th>CHECK IN</th>
                    <td><input id="checkin_date" type="date" /></td>
                    <td><input id="checkin_time" type="time" /></td>
                    <th>CHECK OUT</th>
                    <td><input id="checkout_date" type="date" /></td>
                    <td><input id="checkout_time" type="time" /></td>
                    <td><input placeholder="Infants" id="infants" type="number" inputmode="numeric" min="0" step="1" /></td>
                    <td><input placeholder="Children" id="children" type="number" inputmode="numeric" min="0" step="1" /></td>
                    <td><input placeholder="Total" id="total" type="number" inputmode="numeric" min="0" step="1" /></td>
                </tr>

            </tbody>
        </table>

        <!-- Bulk room import -->
        <div class="bulk-row">

                <input id="gentsBulk" type="text" placeholder="Gents Rooms: 501-502-503" />
                <input id="ladiesBulk" type="text" placeholder="Ladies Rooms: 401-402-403" />
                <button id="btnBulkLoad" type="button">Load</button>
                <span id="bulkReport" class="muted"></span>
        </div>
     
        <script>
            /* ========= Bulk Rooms: multi-separator + bold big beds count ========= */

            /* Split by: comma, slash, asterisk, dash, any whitespace (space/newline/tab) */
            function bulkParse(str) {
                if (!str) return [];
                const parts = str
                    .split(/[,\s\/\*\-\.]+/)      // separators: ,  /  *  -  any whitespace
                    .map(s => s.trim())
                    .filter(Boolean);

                // de-dupe case-insensitively, preserve order
                const out = [];
                const seen = new Set();
                for (const r of parts) {
                    const k = r.toLowerCase();
                    if (!seen.has(k)) { seen.add(k); out.push(r); }
                }
                return out;
            }

            /* Replace rows for a group with provided room list */
            function bulkFillGroup(group, rooms) {
                const tbody = document.getElementById(group + "-tbody");
                if (!tbody) return;
                tbody.innerHTML = "";
                if (!rooms.length) { addRow(group); return; }
                rooms.forEach(r => addRow(group, { room_no: r, capacity: "" }));
            }

            /* Sum numeric capacities across both tables (gents + ladies) */
            function sumAssignedBeds() {
                const sumFor = (group) => {
                    let s = 0;
                    document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => {
                        const capEl = tr.querySelector('td:nth-child(2) input');
                        const n = Number(capEl && capEl.value);
                        if (Number.isFinite(n)) s += n;
                    });
                    return s;
                };
                return sumFor('gents') + sumFor('ladies');
            }

            /* Main action: load lists → fetch capacities → show bold big beds count */
            async function bulkLoadRooms() {
                const gRooms = bulkParse(document.getElementById("gentsBulk").value);
                const lRooms = bulkParse(document.getElementById("ladiesBulk").value);

                bulkFillGroup("gents", gRooms);
                bulkFillGroup("ladies", lRooms);

                if (typeof fetchCapacities === "function") {
                    await fetchCapacities();
                }

                const bedsAssigned = sumAssignedBeds();
                const rep = document.getElementById("bulkReport");
                if (rep) {
                    rep.innerHTML = `Beds assigned: <span id="bedsAssignedVal">${bedsAssigned}</span>`;
                    // make it big and bold
                    const val = document.getElementById("bedsAssignedVal");
                    rep.style.fontWeight = "700";
                    rep.style.fontSize = "22px";
                    rep.style.color = "blue";
                    if (val) { val.style.fontWeight = "800"; val.style.fontSize = "26px"; }
                }

                if (typeof updateTotals === "function") updateTotals();
                const s = document.getElementById("status");
                if (s) s.textContent = `Bulk loaded; beds assigned = ${bedsAssigned}.`;
            }

            /* Wire the button and Enter key on inputs */
            (function wireBulk() {
                const btn = document.getElementById("btnBulkLoad");
                if (btn) btn.addEventListener("click", bulkLoadRooms);
                ["gentsBulk", "ladiesBulk"].forEach(id => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    el.addEventListener("keydown", e => {
                        if (e.key === "Enter") { e.preventDefault(); bulkLoadRooms(); }
                    });
                });
            })();
        </script>




        <div class="subtables" style="margin-top:16px;">
            <table class="mini" id="tblGents">
                <caption>GENTS — Rooms</caption>
                <!-- GENTS header: was Room No | Capacity | [X] -->
                <thead>
                    <tr>
                        <th style="width:50%">Room No</th>
                        <th style="width:22%">Capacity</th>
                        <th style="width:18%">Assigned</th>
                        <th style="width:10%"></th>
                    </tr>
                </thead>

                <tbody id="gents-tbody"></tbody>
                <tfoot>
                    <tr><td colspan="3"><button class="row-btn" onclick="addRow('gents')">Add Row</button></td></tr>
                </tfoot>
            </table>

            <table class="mini" id="tblLadies">
                <caption>LADIES — Rooms</caption>
                <!-- LADIES header: same change -->
                <thead>
                    <tr>
                        <th style="width:50%">Room No</th>
                        <th style="width:22%">Capacity</th>
                        <th style="width:18%">Assigned</th>
                        <th style="width:10%"></th>
                    </tr>
                </thead>

                <tbody id="ladies-tbody"></tbody>
                <tfoot>
                    <tr><td colspan="3"><button class="row-btn" onclick="addRow('ladies')">Add Row</button></td></tr>
                </tfoot>
            </table>
        </div>

        <div class="toolbar no-print">
            <button id="btnFetchCap">Fetch capacity data</button>
            <button id="btnCheckAvail">Check room availability</button>
        </div>

        <div class="help no-print">
            Use <b>Fetch capacity data</b> after you enter room numbers. Unknown rooms show capacity placeholder <b>“unassigned.”</b><br />
            Use <b>Check room availability</b> to catch conflicts before saving.
        </div>

        <div class="controls no-print">
            <button id="btnNew">New Slip</button>
            <button id="btnSave">Save</button>
            <button id="btnEdit">Edit</button>
            <span class="muted" id="status"></span>
        </div>
    </div>

    <script>
        /* -------------------------- IndexedDB setup -------------------------- */
        const DB_NAME = 'pms_accommodation_db';
        const STORE = 'slips';
        const DB_VERSION = 2;

        function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, DB_VERSION);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    let store;
                    if (!db.objectStoreNames.contains(STORE)) {
                        store = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
                    } else {
                        store = e.target.transaction.objectStore(STORE);
                    }
                    if (!store.indexNames.contains('createdAt')) store.createIndex('createdAt', 'createdAt', { unique: false });
                    if (!store.indexNames.contains('tour_name')) store.createIndex('tour_name', 'tour_name', { unique: false });
                    if (!store.indexNames.contains('sh_no')) store.createIndex('sh_no', 'sh_no', { unique: false });
                    if (!store.indexNames.contains('building')) store.createIndex('building', 'building', { unique: false });
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
        async function addRecord(data) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readwrite');
                const store = tx.objectStore(STORE);
                const req = store.add(data);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
                tx.oncomplete = () => db.close();
            });
        }
        async function updateRecord(id, patch) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readwrite');
                const store = tx.objectStore(STORE);
                const getReq = store.get(Number(id));
                getReq.onsuccess = () => {
                    const old = getReq.result;
                    if (!old) { reject(new Error('Record not found')); return; }
                    const updated = { ...old, ...patch, id: old.id, createdAt: old.createdAt, updatedAt: new Date().toISOString() };
                    const putReq = store.put(updated);
                    putReq.onsuccess = () => resolve(updated.id);
                    putReq.onerror = () => reject(putReq.error);
                };
                getReq.onerror = () => reject(getReq.error);
                tx.oncomplete = () => db.close();
            });
        }
        async function getAllRecords() {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readonly');
                const store = tx.objectStore(STORE);
                const req = store.getAll();
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => reject(req.error);
                tx.oncomplete = () => db.close();
            });
        }
        async function getRecord(id) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readonly');
                const store = tx.objectStore(STORE);
                const req = store.get(Number(id));
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => reject(req.error);
                tx.oncomplete = () => db.close();
            });
        }
        function reqToPromise(req) {
            return new Promise((resolve, reject) => {
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
        function toTs(v) {
            if (!v) return 0;
            if (v instanceof Date) return +v;
            const n = Date.parse(v);
            if (!Number.isNaN(n)) return n;
            const k = Number(v);
            return Number.isFinite(k) ? k : 0;
        }
        function toNum(v) {
            const n = Number(v);
            return Number.isFinite(n) ? n : 0;
        }
        function shCandidates(sh) {
            const raw = String(sh ?? "").trim();
            const out = [raw];
            const num = Number(raw);
            if (!Number.isNaN(num)) out.push(num);
            return [...new Set(out)];
        }

        /* FIXED VERSION */
        async function getLatestBySh(sh) {
            const db = await openDB();
            const tx = db.transaction(STORE, 'readonly');
            const store = tx.objectStore(STORE);
            const cands = shCandidates(sh);
            let rows = [];

            try {
                if (store.indexNames.contains('sh_no')) {
                    const idx = store.index('sh_no');
                    for (const key of cands) {
                        const chunk = await reqToPromise(idx.getAll(key));
                        if (Array.isArray(chunk) && chunk.length) rows.push(...chunk);
                    }
                } else {
                    const all = await reqToPromise(store.getAll());
                    rows = all.filter(r =>
                        cands.includes(r.sh_no) || cands.includes(Number(r.sh_no))
                    );
                }

                rows.sort((a, b) => {
                    const tb = toTs(b.createdAt), ta = toTs(a.createdAt);
                    if (tb !== ta) return tb - ta;
                    return toNum(b.id) - toNum(a.id);
                });

                return rows[0] || null;
            } finally {
                // Let the transaction finish before closing
                setTimeout(() => { try { db.close(); } catch (_) { } }, 0);
            }
        }

        /* ------------------------------ Helpers ----------------------------- */
        function $(id) { return document.getElementById(id); }
        let CURRENT_ID = null;
        let DB_CACHE = []; // for capacity + availability lookup

        function pad(n) { return String(n).padStart(2, '0'); }
        function parseDT(d, t) { if (!d) return null; const tt = t && t.length ? t : '00:00'; const v = new Date(`${d}T${tt}`); return isNaN(v) ? null : v; }
        function fmt(dt) { if (!dt) return ''; return new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(dt); }
        function cleanRoom(x) { return String(x ?? '').trim(); }
        function uniq(arr) { return Array.from(new Set(arr)); }

        async function refreshDBCache() {
            DB_CACHE = await getAllRecords();
        }

function addRow(group, data = { room_no: '', capacity: '', assigned: '' }) {
  const tbody = $(group + '-tbody');
  const tr = document.createElement('tr');

  // Room
  const tdRoom = document.createElement('td');
  const inpRoom = document.createElement('input');
  inpRoom.type = 'text';
  inpRoom.placeholder = '';
  inpRoom.value = data.room_no || '';
  tdRoom.appendChild(inpRoom);

  // Capacity (reference/nominal)
  const tdCap = document.createElement('td');
  const inpCap = document.createElement('input');
  inpCap.type = 'number';
  inpCap.min = '0';
  inpCap.step = '1';
  inpCap.inputMode = 'numeric';
  inpCap.value = data.capacity ?? '';
  tdCap.appendChild(inpCap);

  // Assigned (what you actually assign right now)
  const tdAsg = document.createElement('td');
  const inpAsg = document.createElement('input');
  inpAsg.type = 'number';
  inpAsg.min = '0';
  inpAsg.step = '1';
  inpAsg.inputMode = 'numeric';
  inpAsg.placeholder = 'assigned';
  inpAsg.value = data.assigned ?? '';
  tdAsg.appendChild(inpAsg);

  // Delete
  const tdDel = document.createElement('td');
  const btnDel = document.createElement('button');
  btnDel.className = 'row-btn';
  btnDel.type = 'button';
  btnDel.textContent = 'X';
  btnDel.title = 'Delete row';
  btnDel.onclick = () => tr.remove();
  tdDel.appendChild(btnDel);

  tr.append(tdRoom, tdCap, tdAsg, tdDel);
  tbody.appendChild(tr);
}


function collectRows(group) {
  const rows = [];
  document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => {
    const [roomNoEl, capEl, asgEl] = tr.querySelectorAll('input');
    const room_no = (roomNoEl?.value || '').trim();

    const capRaw = (capEl?.value || '').trim();
    const capacity = /^\d+$/.test(capRaw) ? Number(capRaw) : '';

    const asgRaw = (asgEl?.value || '').trim();
    const assigned = /^\d+$/.test(asgRaw) ? Number(asgRaw) : '';

    // Only push if anything is filled
    if (room_no !== '' || capRaw !== '' || asgRaw !== '') {
      rows.push({ room_no, capacity, assigned });
    }
  });
  return rows;
}


function setRows(group, arr) {
  const tbody = $(group + '-tbody');
  tbody.innerHTML = '';
  if (!arr || !arr.length) { addRow(group); return; }
  arr.forEach(r => addRow(group, r)); // r may include r.assigned
}


        function getFormData() {
            return {
                tour_name: $('tour_name').value.trim(),
                group_leader: $('group_leader').value.trim(),
                checkin_date: $('checkin_date').value || '',
                checkin_time: $('checkin_time').value || '',
                checkout_date: $('checkout_date').value || '',
                checkout_time: $('checkout_time').value || '',
                building: $('building').value || '',
                sh_no: $('sh_no').value === '' ? '' : Number($('sh_no').value),
                total: $('total').value === '' ? '' : Number($('total').value),
                gents: $('gents').value === '' ? '' : Number($('gents').value),
                ladies: $('ladies').value === '' ? '' : Number($('ladies').value),
                infants: $('infants').value === '' ? '' : Number($('infants').value),
                children: $('children').value === '' ? '' : Number($('children').value),
                rooms: {
                    gents: collectRows('gents'),
                    ladies: collectRows('ladies')
                },
                createdAt: new Date().toISOString()
            };
        }

        function setFormData(data) {
            $('tour_name').value = data.tour_name || '';
            $('group_leader').value = data.group_leader || '';
            $('checkin_date').value = data.checkin_date || '';
            $('checkin_time').value = data.checkin_time || '';
            $('checkout_date').value = data.checkout_date || '';
            $('checkout_time').value = data.checkout_time || '';
            $('building').value = data.building || '';
            $('sh_no').value = data.sh_no ?? '';
            $('total').value = data.total ?? '';
            $('gents').value = data.gents ?? '';
            $('ladies').value = data.ladies ?? '';
            $('infants').value = data.infants ?? '';
            $('children').value = data.children ?? '';
            setRows('gents', data.rooms?.gents || []);
            setRows('ladies', data.rooms?.ladies || []);
        }

        function clearForm() {
            CURRENT_ID = null;
            setFormData({
                tour_name: '', group_leader: '', checkin_date: '', checkin_time: '',
                checkout_date: '', checkout_time: '', building: '', sh_no: '',
                total: '', gents: '', ladies: '', infants: '', children: '',
                rooms: { gents: [], ladies: [] }
            });
        }

        /* ------------------------ Saved list UI ------------------------ */
       

        /* ---------------- Capacity lookup (most recent per building|room) --------------- */
        function buildCapacityMap(buildingFilter) {
            const cap = new Map(); // key: building|room -> capacity
            const items = [...DB_CACHE].sort((a, b) => (a.createdAt > b.createdAt ? -1 : 1));
            for (const r of items) {
                const b = (r.building || '').trim();
                if (buildingFilter && b !== buildingFilter) continue;
                (r.rooms?.gents || []).forEach(x => {
                    const key = `${b}|${cleanRoom(x.room_no)}`;
                    const c = (x.capacity === '' || x.capacity == null) ? null : Number(x.capacity);
                    if (!cap.has(key) && c != null) cap.set(key, c);
                });
                (r.rooms?.ladies || []).forEach(x => {
                    const key = `${b}|${cleanRoom(x.room_no)}`;
                    const c = (x.capacity === '' || x.capacity == null) ? null : Number(x.capacity);
                    if (!cap.has(key) && c != null) cap.set(key, c);
                });
            }
            return cap;
        }

        function setUnassigned(input) {
            input.value = '';
            input.placeholder = 'unassigned';
        }

        /* Fill capacities for both tables based on entered rooms */
        async function fetchCapacities() {
            await refreshDBCache();
            const b = ($('building').value || '').trim();
            if (!b) { alert('Select a building first.'); return; }
            const capMap = buildCapacityMap(b);

            let filled = 0, unknown = 0;

            ['gents', 'ladies'].forEach(group => {
                document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => {
                    tr.classList.remove('okfill');
                    const [roomEl, capEl] = tr.querySelectorAll('input');
                    const room = cleanRoom(roomEl.value);
                    if (!room) return;
                    const key = `${b}|${room}`;
                    if (capMap.has(key)) {
                        capEl.value = capMap.get(key);
                        capEl.placeholder = '';
                        tr.classList.add('okfill');
                        filled++;
                    } else {
                        setUnassigned(capEl);
                        unknown++;
                    }
                });
            });

            $('status').textContent = `Capacity fetch: filled ${filled} item(s); ${unknown} unassigned.`;
        }

        /* ---------------- Availability check ---------------- */
        function overlaps(aStart, aEnd, bStart, bEnd) {
            return aStart < bEnd && aEnd > bStart; // [start, end)
        }

        function highlightConflicts(confRooms) {
            // wipe
            ['gents', 'ladies'].forEach(group => {
                document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => tr.classList.remove('conflict'));
            });
            if (!confRooms.size) return;
            ['gents', 'ladies'].forEach(group => {
                document.querySelectorAll(`#${group}-tbody tr`).forEach(tr => {
                    const [roomEl] = tr.querySelectorAll('input');
                    const room = cleanRoom(roomEl.value);
                    if (confRooms.has(room)) tr.classList.add('conflict');
                });
            });
        }

        async function checkAvailability() {
            await refreshDBCache();

            const bld = ($('building').value || '').trim();
            const ci = parseDT($('checkin_date').value, $('checkin_time').value);
            const co = parseDT($('checkout_date').value, $('checkout_time').value);

            if (!bld || !ci || !co || co <= ci) {
                alert('Enter a valid building and check-in/check-out window first.');
                return false;
            }

            const rooms = [...collectRows('gents'), ...collectRows('ladies')].map(r => cleanRoom(r.room_no)).filter(Boolean);
            const uniqRooms = uniq(rooms);
            //commented if(!uniqRooms.length){ alert('Enter at least one room number.'); return false; }

            const conflicts = new Map(); // room -> {freeAt: Date, stays: [rec]}
            for (const r of DB_CACHE) {
                if (CURRENT_ID && r.id === CURRENT_ID) continue; // ignore self
                const rb = (r.building || '').trim();
                if (rb !== bld) continue;

                const rci = parseDT(r.checkin_date, r.checkin_time);
                const rco = parseDT(r.checkout_date, r.checkout_time);
                if (!rci || !rco) continue;

                // if no overlap with our overall window, skip
                if (!overlaps(ci, co, rci, rco)) continue;

                const usedRooms = [
                    ...(r.rooms?.gents || []).map(x => cleanRoom(x.room_no)),
                    ...(r.rooms?.ladies || []).map(x => cleanRoom(x.room_no))
                ].filter(Boolean);

                for (const room of uniqRooms) {
                    if (usedRooms.includes(room)) {
                        const entry = conflicts.get(room) || { freeAt: rco, stays: [] };
                        // latest checkout among overlapping stays decides "free at"
                        entry.freeAt = entry.freeAt && entry.freeAt > rco ? entry.freeAt : rco;
                        entry.stays.push({
                            tour: r.tour_name || '',
                            leader: r.group_leader || '',
                            sh: r.sh_no ?? '',
                            win: `${fmt(rci)} → ${fmt(rco)}`
                        });
                        conflicts.set(room, entry);
                    }
                }
            }

            const confRooms = new Set(conflicts.keys());
            highlightConflicts(confRooms);

            if (confRooms.size) {
                const lines = [];
                for (const room of confRooms) {
                    const c = conflicts.get(room);
                    lines.push(`${room} is occupied; will be empty at ${fmt(c.freeAt)}.`);
                }
                alert(lines.join('\n') + '\nEnter another room to proceed.');
                $('status').textContent = `${confRooms.size} room(s) in conflict.`;
                return false;
            } else {
                alert('All entered rooms are available in the selected window.');
                $('status').textContent = 'Availability OK.';
                return true;
            }
        }

        /* ---------------------------- Events --------------------------- */

        $('btnSave').addEventListener('click', async () => {
            try {
                const data = getFormData();
                const ok = await checkAvailability(); // optional guard; comment out if you want silent save
                if (ok === false) return;
                const id = await addRecord(data);
                CURRENT_ID = id;
                $('status').textContent = `Saved as #${id}`;
                await refreshSavedList();
            } catch (err) {
                $('status').textContent = 'Save failed. Check console.';
                console.error('Save error:', err);
                alert('Failed to save. Your browser may block IndexedDB in this context.');
            }
        });

        $('btnEdit').addEventListener('click', async () => {
            try {
                if (!CURRENT_ID) { alert('Load a slip (Saved list or SH Fetch) before editing.'); return; }
                const data = getFormData();
                const ok = await checkAvailability(); // validate before edit too
                if (ok === false) return;
                delete data.createdAt; // keep original
                const id = await updateRecord(CURRENT_ID, data);
                $('status').textContent = `Updated #${id}`;
                await refreshSavedList();
            } catch (err) {
                $('status').textContent = 'Edit failed. See console.';
                console.error('Edit error:', err);
                alert('Edit failed.');
            }
        });

    

        $('btnNew').addEventListener('click', () => {
            clearForm();
            $('status').textContent = 'New blank slip';
        });

        $('btnFetchSh').addEventListener('click', async () => {
            const raw = $('sh_no').value;
            if (raw === '' || isNaN(Number(raw))) { alert('Enter a valid SH No.'); return; }
            const rec = await getLatestBySh(Number(raw));
            if (!rec) { $('status').textContent = 'No slip found for that SH.'; return; }
            CURRENT_ID = rec.id;
            setFormData(rec);
            $('status').textContent = `Loaded latest slip for SH ${rec.sh_no} (#${rec.id})`;
        });

        $('sh_no').addEventListener('blur', async () => {
            const hasAny = ($('tour_name').value || $('group_leader').value || $('building').value);
            if (hasAny) return;
            const raw = $('sh_no').value;
            if (raw !== '' && !isNaN(Number(raw))) {
                const rec = await getLatestBySh(Number(raw));
                if (rec) {
                    CURRENT_ID = rec.id;
                    setFormData(rec);
                    $('status').textContent = `Auto-loaded latest slip for SH ${rec.sh_no} (#${rec.id})`;
                }
            }
        });

        $('btnFetchCap').addEventListener('click', fetchCapacities);
        $('btnCheckAvail').addEventListener('click', checkAvailability);

        /* ------------------------------ Boot ------------------------------- */
        (async function boot() {
            clearForm();
            addRow('gents'); addRow('ladies');
            await refreshDBCache();
        })();
    </script>
</body>
</html>
